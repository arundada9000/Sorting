<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Sort</title>
    <meta name="description" content="heap sort visualized step by step with its time and space complexities" />
    <meta name="keyword"
        content="heap sort, heap sort visualized,step by step, heap sort in easy way, time complexity, space complexity, heap sort properties, arun neupane,sorting" />
    <link rel="icon" href="./images/sort.png" type="image/x-icon">
    <link rel="stylesheet" href="./styles.css">

    <style>
        .heap-tree-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .heap-tree {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow: auto;
            margin: 1rem 0rem;
            animation: fadeInPopup 0.5s ease forwards;
            max-width: 100vw;
        }

        .node-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
        }

        .node-container:last-child {
            justify-content: start;
        }

        .node {
            height: 40px;
            width: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4F6D7A;
            color: white;
            cursor: pointer;
            animation: fadeInPopup 0.75s ease forwards;
        }

        .child {
            transform: scale(1.25);
            background-color: red;
        }

        .parent {
            transform: scale(1.25);
            background-color: red;
        }

        .comparing {
            background-color: #f39c12;
        }

        .swapping {
            background-color: #e74c3c;
            transform: scale(1.2);
        }

        .sorted {
            background-color: #27ae60;
            color: white;
        }
    </style>
</head>

<body>
    <nav>
        <div class="menu-toggle" onclick="toggleMenu()">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="nav-links1">
            <a href="./index.html">Home</a>
            <a href="./bubbleSort.html">Bubble</a>
            <a href="./selectionSort.html">Selection</a>
            <a href="./insertionSort.html">Insertion</a>
            <a href="./mergeSort.html">Merge</a>
            <a href="./quickSort.html">Quick</a>
            <a href="./heapSort.html" class="bb">Heap</a>
            <a href="./radixSort.html">Radix</a>
            <a href="./shellSort.html">Shell</a>
            <a href="./summary.html">Summary</a>
        </div>
        <div class="nav-links">
            <a href="./index.html">Home</a>
            <a href="./bubbleSort.html">Bubble Sort</a>
            <a href="./selectionSort.html">Selection Sort</a>
            <a href="./insertionSort.html">Insertion Sort</a>
            <a href="./mergeSort.html">Merge Sort</a>
            <a href="./quickSort.html">Quick Sort</a>
            <a href="./heapSort.html" class="bb">Heap Sort</a>
            <a href="./radixSort.html">Radix Sort</a>
            <a href="./shellSort.html">Shell Sort</a>
            <a href="./summary.html">Summary</a>
        </div>
    </nav>
    <div class="progress-bar-container">
        <div class="progress-bar"></div>
    </div>
    <div class="container">
        <section class="front">
            <div class="front-main">
                <div class="icon-container">
                    <img src="./images/heap.webp" alt="heap sort">
                    <h1>Heap Sort</h1>
                </div>

                <div class="sort-input">

                    <input type="text" id="input-num" label="Enter numbers" title="Enter numbers separated with commas"
                        placeholder="Enter numbers separated with commas as 1,2,3,4">

                    <div class="buttons-div">
                        <div class="sort-btn" id="generate-random-btn" title="Generate random numbers button"
                            onclick="randomGenerate();">
                            <img src="./images/magic.png" alt="Generate Random Numbers" title="Generate random numbers">
                        </div>
                        <button id="sort-btn" class="sort-btn">Sort</button>
                    </div>
                </div>
            </div>
            <div class="buttons-div"><button id="fast-btn" class="control-btn">Fast Visualization</button>
                <button id="skip" class="control-btn">Skip Visualization</button>
            </div>
            <div class="passesandinfo">
                <div class="numbers" id="num-div"></div>
                <div class="heap-tree-wrapper">
                    <div class="heap-tree"></div>
                </div>
                <div class="passes" id="passes"></div>
            </div>
        </section>

        <div class="howto-wrapper  scroll-animate">
            <div class="howto" id="howto">
                <div class="qs">
                    <h3>How to use ?</h3>
                    <button class="show">+</button>
                    <button class="hide">-</button>
                </div>
                <div class="ans">
                    <p>
                        Enter an array separated by commas as : 1,2,4,3,5 then press enter or Sort button. Sorting
                        will
                        start
                        and
                        you can watch each pass as it gets sorted.
                        When it shows green it means the two of them are
                        being
                        compared
                        when red shows, it means the left number is greater than right number so it needs swapping
                        The blue color means the number is
                        at its
                        correct position and thus sorted
                        it will continue to check other numbers until it reaches end.
                    </p>
                </div>
            </div>
        </div>

        <div class="sorting-algorithm-container">
            <h1 class="algorithm-title  scroll-animate">Heap Sort Overview</h1>

            <section class="history scroll-animate">
                <h2 class="section-title">History</h2>
                <p>Heap sort is based on the binary heap data structure and was developed in the 1960s. It is considered
                    an efficient sorting algorithm and is often used in systems that require high performance.</p>
            </section>

            <section class="current-uses scroll-animate">
                <h2 class="section-title">Current Uses</h2>
                <ul>
                    <li><strong>Data Processing:</strong> Used in systems that require efficient sorting and management
                        of data.</li>
                    <li><strong>Priority Queues:</strong> Often employed in implementing priority queues due to its
                        underlying heap structure.</li>
                    <li><strong>Embedded Systems:</strong> Suitable for environments with limited memory resources.</li>
                </ul>
            </section>

            <section class="complexity scroll-animate">
                <h2 class="section-title">Time and Space Complexity</h2>
                <h3>Time Complexity</h3>
                <ul>
                    <li><strong>Best Case:</strong> <code>O(n log n)</code> – Performance is consistent regardless of
                        input.</li>
                    <li><strong>Average Case:</strong> <code>O(n log n)</code> – Efficient average performance.</li>
                    <li><strong>Worst Case:</strong> <code>O(n log n)</code> – Consistent performance even in the worst
                        case.</li>
                </ul>
                <h3>Space Complexity</h3>
                <p><strong>Space Complexity:</strong> <code>O(1)</code> – It is an in-place sorting algorithm that
                    requires minimal additional space.</p>
            </section>

            <section class="pseudo-code scroll-animate">
                <h2 class="section-title">Pseudo Code</h2>
                <div class="code-container">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code><!-- Heap sort -->function heapSort(arr):
    n = length(arr)
    // Build heap (rearrange array)
    for i from n/2 - 1 to 0:
        heapify(arr, n, i)
    // One by one extract elements from heap
    for i from n-1 to 0:
        swap arr[0] and arr[i]
        heapify(arr, i, 0)

function heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    if largest != i:
        swap arr[i] and arr[largest]
        heapify(arr, n, largest)</code></pre>
                </div>
            </section>

            <section class="characteristics scroll-animate">
                <h2 class="section-title">Key Characteristics</h2>
                <ul>
                    <li><strong>In-Place:</strong> Heap sort operates in place, requiring minimal additional memory.
                    </li>
                    <li><strong>Not Stable:</strong> The algorithm is not stable, as equal elements may change order.
                    </li>
                </ul>
            </section>

            <section class="summary scroll-animate">
                <h2 class="section-title">Summary</h2>
                <p>Heap sort is a comparison-based sorting algorithm that utilizes the properties of a binary heap. With
                    a time complexity of <code>O(n log n)</code>, it is efficient and suitable for applications
                    requiring guaranteed performance.</p>
            </section>
        </div>

    </div>
    <button id="backToTopBtn" title="Go to top">↑</button>

    <footer class="site-footer">
        <div class="footer-container">
            <p class="footer-title">Sorting Visualizer</p>
            <div class="footer-links">
                <a href="https://github.com/arundada9000/Sorting" target="_blank" rel="noopener">Source Code</a> |
                <a href="https://arunneupane.netlify.app/" target="_blank" rel="noopener">Portfolio</a> |
                <a href="./contact.html">Contact</a>
            </div>
            <p class="footer-info">&copy; <span id="year">2024</span> Sorting Visualizer. All rights reserved.</p>
            <p class="footer-credit">Made with ❤️ by Arun Neupane</p>
            <p class="footer-credit">For Learning and Development</p>
        </div>
    </footer>

    <script>
        const sortBtn = document.getElementById("sort-btn");
        const inputBox = document.getElementById("input-num");
        const passesDiv = document.getElementById("passes");
        const howto = document.getElementById("howto");
        const skipBtn = document.getElementById("skip");
        const fastBtn = document.getElementById("fast-btn");
        let ms = 1000, passCount = 0;

        sortBtn.addEventListener("click", () => {
            if (sortBtn.textContent == "Sorting...") return;
            let input = inputBox.value.trim();
            if (input == "") {
                alert("Please enter some values ! ");
                return;
            }
            ms = 1000; passCount = 0;
            displayBtn("inline");
            sortBtn.textContent = "Sorting...";

            const values = input.split(',');

            const numDiv = document.getElementById("num-div");
            numDiv.innerHTML = "";
            passesDiv.innerHTML = "";
            howto.innerHTML = "";
            howto.style.visibility = "hidden";
            document.querySelector(".heap-tree").innerHTML = "";

            for (let i = 0; i < values.length; i++) {
                let el = document.createElement("div");
                el.className = "num-wrapper";

                let li = document.createElement("div");
                li.className = "num";
                li.textContent = values[i];
                values[i] = parseFloat(values[i]);

                let li1 = document.createElement("p");
                li1.classList = "ij";
                li1.textContent = i;
                el.appendChild(li1);
                el.appendChild(li);
                numDiv.appendChild(el);
            }
            const divs = document.querySelectorAll(".num");

            heapVisualized(values);
            const nodes = document.querySelectorAll(".node");


            heapSort();
            async function heapSort() {
                await sleep(ms);
                const length = values.length;
                let i;
                for (i = Math.floor(length / 2); i >= 0; i--) {
                    await heapify(values, length, i);
                }

                for (i = length - 1; i > 0; i--) {
                    [values[0], values[i]] = [values[i], values[0]];
                    await sleep(ms);
                    toggleClass("swapping", true, nodes[0], nodes[i]);
                    await sleep(ms);
                    nodes[0].textContent = values[0];
                    nodes[i].textContent = values[i];
                    nodes[i].classList.add("sorted");
                    await sleep(ms);
                    toggleClass("swapping", false, nodes[i], nodes[0]);
                    await heapify(values, i, 0);

                    passCount++;
                    let passes = createDiv("numbers", "num", values, values.length, i, passCount);
                    passesDiv.appendChild(passes);
                }
                passCount++;
                let passes = createDiv("numbers", "num", values, values.length, i, passCount);
                passesDiv.appendChild(passes);
                nodes[0].classList.add("sorted");

                sortedArray = values.join(", ");
                howto.style.visibility = "visible";
                howto.innerHTML = "The array is successfully sorted.There were " + values.length + " numbers and it took " + (values.length - 1) + " passes.The sorted array is : <br>" + sortedArray;

                const btn = document.createElement("button");
                btn.textContent = "Copy";
                btn.className = "copy-btn";
                btn.id = "ans-copy-btn";
                btn.addEventListener("click", () => {
                    navigator.clipboard.writeText(sortedArray);
                    btn.textContent = "Copied!";
                    setTimeout(() => {
                        btn.textContent = "Copy";
                    }, 2000);
                });
                howto.appendChild(btn);

                displayBtn("none");
                sortBtn.textContent = "Sort";
            }

            async function heapify(values, length, rootIndex) {
                let largest = rootIndex;
                const leftChild = 2 * rootIndex + 1;
                const rightChild = 2 * rootIndex + 2;

                // Check if leftChild and rightChild are within bounds before passing to toggleClass
                const nodesToCompare = [nodes[rootIndex]];
                if (leftChild < length) nodesToCompare.push(nodes[leftChild]);
                if (rightChild < length) nodesToCompare.push(nodes[rightChild]);

                // Add the comparing class to the nodes being compared
                toggleClass("comparing", true, ...nodesToCompare);
                await sleep(ms);

                // If left child is larger than root
                if (leftChild < length && values[leftChild] > values[largest]) {
                    largest = leftChild;
                }

                // If right child is larger than the largest so far
                if (rightChild < length && values[rightChild] > values[largest]) {
                    largest = rightChild;
                }

                // Remove the comparing class after comparisons are done
                toggleClass("comparing", false, ...nodesToCompare);

                // If largest is not root, swap and update nodes
                if (largest !== rootIndex) {
                    // Swap values in the array
                    [values[rootIndex], values[largest]] = [values[largest], values[rootIndex]];

                    // Add the swapping class to indicate the swap visually
                    toggleClass("swapping", true, nodes[rootIndex], nodes[largest]);
                    await sleep(ms);

                    // Update the text content of the swapped nodes
                    nodes[rootIndex].textContent = values[rootIndex];
                    nodes[largest].textContent = values[largest];
                    await sleep(ms);
                    // Remove the swapping class after the swap
                    toggleClass("swapping", false, nodes[rootIndex], nodes[largest]);

                    // Recursively heapify the affected subtree
                    await heapify(values, length, largest);
                }
            }

        });

        function createDiv(cn1, cn2, content, time, j, passCount) {
            const outerDiv = document.createElement("div");
            outerDiv.className = cn1;

            const li = document.createElement("div");
            li.className = cn2;
            if (passCount == time)
                li.textContent = "Sorted ";
            else
                li.textContent = "Pass " + passCount;
            outerDiv.appendChild(li);

            for (let i = 0; i < time; i++) {
                const li = document.createElement("div");
                li.className = cn2;
                if (i >= j)
                    li.classList.add("sorted");
                li.textContent = content[i];
                outerDiv.appendChild(li);
            }

            return outerDiv;
        }

        function toggleClass(className, add, ...elements) {
            elements.forEach(element => {
                if (element instanceof HTMLElement) {
                    if (add) {
                        element.classList.add(className);
                    } else
                        element.classList.remove(className);
                } else {
                    console.error('Invalid element:', element);
                }
            });
        }

        function heapVisualized(data) {
            const heapTree = document.querySelector(".heap-tree");
            let size = data.length;
            let tSize = size;
            let counter = 0, wid;
            let depth = Math.ceil(Math.log2(data.length));
            if (size % Math.pow(2, depth) == 0) {
                depth++;
            }

            for (let i = 0; i < depth; i++) {

                let div = document.createElement("div");
                div.className = "node-container";
                let end = Math.pow(2, i);

                if (i == depth - 1) {
                    if (tSize > Math.pow(2, i - 1)) {
                        wid = tSize;
                    }
                    else {
                        wid = Math.pow(2, i - 1) + tSize;
                    }
                }

                for (let j = 0; j < end && counter < size; j++) {
                    console.log(counter, size, end, depth);
                    let idiv = document.createElement("div");
                    idiv.textContent = data[counter];
                    counter++;
                    idiv.className = "node";
                    div.appendChild(idiv);
                    tSize--;
                }

                heapTree.appendChild(div);
            }

            let maxWidth = wid * 40 + (10 * (wid - 1));

            const nodeContainers = document.querySelectorAll(".node-container");
            nodeContainers.forEach(nodeContainer => {
                nodeContainer.style.width = `${maxWidth}px`
            });

            scrollToMid(nodeContainers);

            let nodes = document.querySelectorAll(".node");
            nodes.forEach((node, index) => {
                node.addEventListener("mouseover", () => {
                    if (2 * index + 1 < size) {
                        nodes[2 * index + 1].classList.add("child");
                        if (2 * index + 2 < size)
                            nodes[2 * index + 2].classList.add("child");
                    }
                    if (index > 0) {
                        nodes[Math.floor((index - 1) / 2)].classList.add("parent");
                    }
                });
                node.addEventListener("mouseout", () => {
                    if ((2 * index + 1) < size) {
                        nodes[2 * index + 1].classList.remove("child");
                        if ((2 * index + 2) < size)
                            nodes[2 * index + 2].classList.remove("child");
                    }
                    if (index > 0) {
                        nodes[Math.floor((index - 1) / 2)].classList.remove("parent");
                    }
                });
            });
        }

        function scrollToMid(nodeContainers) {
            nodeContainers.forEach(node => {
                node.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'center'
                });
            });

        }
    </script>
    <script src="./script.js"></script>
</body>

</html>