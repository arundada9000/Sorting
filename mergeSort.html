<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Sort</title>
    <meta name="description" content="Merge sort visualized step by step with its time and space complexities" />
    <meta name="keywords"
        content="merge sort, merge sort visualized,step by step, merge sort in easy way, time complexity, space complexity, merge sort properties, arun neupane,sorting" />
    <link rel="icon" href="./images/sort.png" type="image/x-icon">
    <link rel="stylesheet" href="./styles.css">
    <style>
        .numbers-wrapper {
            display: flex;
            border: 5px solid green;
        }
    </style>
</head>

<body>
    <nav>
        <div class="menu-toggle" onclick="toggleMenu()">
            <span></span>
            <span></span>
            <span></span>
        </div>

        <div class="nav-links">
            <a href="./index.html">Home</a>
            <a href="./bubbleSort.html">Bubble <span class="sort-text">sort</span></a>
            <a href="./selectionSort.html">Selection <span class="sort-text">sort</span></a>
            <a href="./insertionSort.html">Insertion <span class="sort-text">sort</span></a>
            <a href="./mergeSort.html" class="bb">Merge <span class="sort-text">sort</span></a>
            <a href="./quickSort.html">Quick <span class="sort-text">sort</span></a>
            <a href="./heapSort.html">Heap <span class="sort-text">sort</span></a>
            <a href="./radixSort.html">Radix <span class="sort-text">sort</span></a>
            <a href="./shellSort.html">Shell <span class="sort-text">sort</span></a>
            <a href="./summary.html">Summary</a>
        </div>
    </nav>

    <div class="cursor big"></div>
    <div class="cursor small"></div>

    <div class="progress-bar-container">
        <div class="progress-bar"></div>
    </div>
    <div class="container">
        <section class="front">
            <div class="front-main">
                <div class="icon-container">
                    <img src="./images/merge.webp" alt="merge sort">
                    <h1>Merge Sort</h1>
                </div>

                <div class="sort-input">

                    <input type="text" id="input-num" label="Enter numbers" title="Enter numbers separated with commas"
                         placeholder="Enter numbers separated with commas as 16,15,15,10,1">

                    <div class="buttons-div">
                        <div class="sort-btn" id="generate-random-btn" title="Generate random numbers button"
                            onclick="randomGenerate();">
                            <img src="./images/magic.png" alt="Generate Random Numbers" title="Generate random numbers">
                        </div>
                        <button id="sort-btn" class="sort-btn">Sort</button>
                    </div>
                </div>
            </div>
            <div class="buttons-div"><button id="fast-btn" class="control-btn">Fast Visualization</button>
                <button id="skip" class="control-btn">Skip Visualization</button>
            </div>
            <div class="passesandinfo">
                <div class="numbers" id="num-div"></div>
                <div class="passes" id="passes"></div>
            </div>
        </section>

        <div class="howto-wrapper scroll-animate">
            <div class="howto" id="howto">
                <div class="qs">
                    <h3>How to use ?</h3>
                    <button class="show">+</button>
                    <button class="hide">-</button>
                </div>
                <div class="ans">
                    <p>
                        Enter an array separated by commas as : 1,2,4,3,5 then press enter or Sort button. Sorting
                        will
                        start
                        and
                        you can watch each pass as it gets sorted.
                        When it shows green it means the two of them are
                        being
                        compared
                        when red shows, it means the left number is greater than right number so it needs swapping
                        The blue color means the number is
                        at its
                        correct position and thus sorted
                        it will continue to check other numbers until it reaches end.
                    </p>
                </div>
            </div>
        </div>

        <div class="sorting-algorithm-container">
            <h1 class="algorithm-title scroll-animate">Merge Sort Overview</h1>

            <section class="history scroll-animate">
                <h2 class="section-title">History</h2>
                <p>Merge sort was invented by John von Neumann in 1945. It is a classic divide-and-conquer algorithm
                    that is particularly effective for large datasets and is widely used in computer science and
                    programming.</p>
            </section>

            <section class="current-uses scroll-animate">
                <h2 class="section-title">Current Uses</h2>
                <ul>
                    <li><strong>Large Data Sets:</strong> Often employed for sorting large datasets where performance is
                        critical.</li>
                    <li><strong>Stable Sort:</strong> Utilized in applications where stable sorting is required.</li>
                    <li><strong>External Sorting:</strong> Commonly used in external sorting algorithms for managing
                        large files that do not fit into memory.</li>
                </ul>
            </section>

            <section class="complexity scroll-animate">
                <h2 class="section-title">Time and Space Complexity</h2>
                <h3>Time Complexity</h3>
                <ul>
                    <li><strong>Best Case:</strong> <code>O(n log n)</code> – Consistent performance across all cases.
                    </li>
                    <li><strong>Average Case:</strong> <code>O(n log n)</code> – Maintains efficient performance on
                        average.</li>
                    <li><strong>Worst Case:</strong> <code>O(n log n)</code> – Efficient even in the worst-case
                        scenario.</li>
                </ul>
                <h3>Space Complexity</h3>
                <p><strong>Space Complexity:</strong> <code>O(n)</code> – Requires additional space for the temporary
                    arrays used in the merging process.</p>
            </section>

            <section class="pseudo-code scroll-animate">
                <h2 class="section-title">Pseudo Code</h2>
                <div class="code-container">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre class="pseudo-code-code"><code><!-- Merge sort -->function mergeSort(arr):
    if length(arr) <= 1:
        return arr
    mid = length(arr) / 2
    left = mergeSort(arr[0:mid])
    right = mergeSort(arr[mid:length(arr)])
    return merge(left, right)

function merge(left, right):
    result = []
    while left and right are not empty:
        if left[0] <= right[0]:
            append left[0] to result
            remove left[0]
        else:
            append right[0] to result
            remove right[0]
    append remaining elements of left and right to result
    return result</code></pre>
                </div>
            </section>

            <section class="characteristics scroll-animate">
                <h2 class="section-title">Key Characteristics</h2>
                <ul>
                    <li><strong>Stable:</strong> Merge sort is a stable sorting algorithm.</li>
                    <li><strong>Divide and Conquer:</strong> The algorithm utilizes the divide-and-conquer strategy
                        effectively.</li>
                </ul>
            </section>

            <section class="summary scroll-animate">
                <h2 class="section-title">Summary</h2>
                <p>Merge sort is a powerful and efficient sorting algorithm that consistently performs at
                    <code>O(n log n)</code> complexity. Its stability and performance make it ideal for sorting large
                    datasets and is widely utilized in computer science applications.
                </p>
            </section>

            <section class="language-code-container">
                <h1 class="scroll-animate">Merge Sort Code Implementation</h1>
                <div class="language-selector scroll-animate">
                    <button data-language="c">C</button>
                    <button data-language="cpp">C++</button>
                    <button data-language="javascript">JavaScript</button>
                    <button data-language="python">Python</button>
                    <button data-language="java">Java</button>
                </div>
                <pre class="inside-code-container">
                    <code id="code-display"></code>
                </pre>
                <button class="language-copy-button scroll-animate">Copy</button>
            </section>

        </div>
    </div>
    <button id="backToTopBtn" title="Go to top">↑</button>

    <footer class="site-footer">
        <div class="footer-container">
            <p class="footer-title">Sorting Visualizer</p>
            <div class="footer-links">
                <a href="./about.html">About</a> |
                <a href="https://arunneupane.netlify.app/" target="_blank" rel="noopener">Portfolio</a> |
                <a href="./contact.html">Contact</a>
            </div>
            <p class="footer-info">&copy; <span id="year">2024</span> Sorting Visualizer. All rights reserved.</p>
            <p class="footer-credit">Made with ❤️ by Arun Neupane</p>
            <p class="footer-credit">For Learning and Development</p>
        </div>
    </footer>

    <script>

        const codeSnippets = {
            javascript: `// JavaScript code for Merge Sort
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const mid = Math.floor(arr.length / 2);
    const left = arr.slice(0, mid);
    const right = arr.slice(mid);
    
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
    let result = [], leftIndex = 0, rightIndex = 0;
    
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    
    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}

let arr = [16, 15, 15, 10, 1];
console.log('Before sorting:', arr);
arr = mergeSort(arr);
console.log('After sorting:', arr);`,

            c: `// C code for Merge Sort
#include <stdio.h>
#include <stdlib.h>

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int L[n1], R[n2];
    
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        merge(arr, left, mid, right);
    }
}

int main() {
    int arr[] = {16, 15, 15, 10, 1};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Before sorting: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    mergeSort(arr, 0, n - 1);

    printf("\\nAfter sorting: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}`,

            cpp: `// C++ code for Merge Sort
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    vector<int> L(n1), R(n2);
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        merge(arr, left, mid, right);
    }
}

int main() {
    vector<int> arr = {16, 15, 15, 10, 1};
    
    cout << "Before sorting: ";
    for (int num : arr) {
        cout << num << " ";
    }

    mergeSort(arr, 0, arr.size() - 1);

    cout << "\\nAfter sorting: ";
    for (int num : arr) {
        cout << num << " ";
    }

    return 0;
}`,

            java: `// Java code for Merge Sort
public class SortingAlgorithm {
    public static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] L = new int[n1];
        int[] R = new int[n2];
        
        for (int i = 0; i < n1; i++) L[i] = arr[left + i];
        for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i];
        
        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            
            merge(arr, left, mid, right);
        }
    }

    public static void main(String[] args) {
        int[] arr = {16, 15, 15, 10, 1};
        System.out.print("Before sorting: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }

        mergeSort(arr, 0, arr.length - 1);

        System.out.print("\\nAfter sorting: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}`,

            python: `# Python code for Merge Sort
def merge(arr, left, mid, right):
    n1 = mid - left + 1
    n2 = right - mid
    
    L = arr[left:left + n1]
    R = arr[mid + 1:mid + 1 + n2]
    
    i = j = k = left
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, left, right):
    if left < right:
        mid = (left + right) // 2
        mergeSort(arr, left, mid)
        mergeSort(arr, mid + 1, right)
        merge(arr, left, mid, right)

arr = [16, 15, 15, 10, 1]
print('Before sorting:', arr)
mergeSort(arr, 0, len(arr) - 1)
print('After sorting:', arr)
`
        };


        const sortBtn = document.getElementById("sort-btn");
        const inputBox = document.getElementById("input-num");
        const passesDiv = document.getElementById("passes");
        const howto = document.getElementById("howto");
        const skipBtn = document.getElementById("skip");
        const fastBtn = document.getElementById("fast-btn");
        let ms = 1000;
        let left, right;

        sortBtn.addEventListener("click", () => {
            if (sortBtn.textContent == "Sorting...") return;
            let input = inputBox.value.trim();
            if (input == "") {
                alert("Please enter some values ! ");
                return;
            }
            ms = 1000;
            displayBtn("inline");
            sortBtn.textContent = "Sorting...";

            const values = input.split(',');

            left = values.length / 2;
            right = values.length - left;

            const numDiv = document.getElementById("num-div");
            numDiv.innerHTML = "";
            passesDiv.innerHTML = "";
            howto.innerHTML = "";
            howto.style.visibility = "hidden";
            let pass = 1;
            for (let i = 0; i < values.length; i++) {
                let el = document.createElement("div");
                el.className = "num-wrapper";

                let li = document.createElement("div");
                li.className = "num";
                li.textContent = values[i];
                values[i] = parseFloat(values[i]);

                let li1 = document.createElement("p");
                li1.classList = "ij";
                li1.textContent = i;
                el.appendChild(li1);
                el.appendChild(li);
                numDiv.appendChild(el);
            }
            const divs = document.querySelectorAll(".num");

            let tValues = mergeSort(values);

            sortedArray = tValues.join(", ");
            howto.style.visibility = "visible";
            howto.innerHTML = "The array is successfully sorted.There were " + values.length + " numbers and it took " + (values.length - 1) + " passes.The sorted array is : <br>" + sortedArray;

            const btn = document.createElement("button");
            btn.textContent = "Copy";
            btn.className = "copy-btn";
            btn.id = "ans-copy-btn";
            btn.addEventListener("click", () => {
                navigator.clipboard.writeText(sortedArray);
                btn.textContent = "Copied!";
                setTimeout(() => {
                    btn.textContent = "Copy";
                }, 2000);
            });
            howto.appendChild(btn);

            displayBtn("none");
            sortBtn.textContent = "Sort";

            function mergeSort(array) {
                if (array.length <= 1) {
                    return array;
                }

                const mid = Math.floor(array.length / 2);
                const left = mergeSort(array.slice(0, mid));
                const right = mergeSort(array.slice(mid));

                return merge(left, right);
            }

            function merge(left, right) {
                const sortedArray = [];

                while (left.length && right.length) {
                    if (left[0] < right[0]) {
                        sortedArray.push(left.shift());
                    } else {
                        sortedArray.push(right.shift());
                    }
                }

                // Concatenate remaining elements
                return sortedArray.concat(left).concat(right);
            }

        });

        // divide();
        function divide() {
            let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
            let gap = values.length;
            let power = 0, counter = 0;

            while (gap > 0) {
                const numbersDiv = document.createElement("div");
                numbersDiv.className = "numbers";
                let iterator = 0;

                for (let i = 0; i < Math.pow(2, power); i++) {
                    const numWrapper = document.createElement("div");
                    numWrapper.className = "numbers-wrapper";

                    for (let j = iterator; j < gap && counter < values.length; j++) {
                        const numDiv = document.createElement("div");
                        numDiv.textContent = values[counter];
                        numDiv.className = "num";
                        counter++;
                        numWrapper.appendChild(numDiv);
                    }
                    iterator = gap;
                    gap += gap;
                    gap > values.length ? gap = values.length : gap = gap;
                    numbersDiv.appendChild(numWrapper);
                }
                counter = 0;
                passesDiv.appendChild(numbersDiv);
                gap = parseInt(gap / 2);
                power++;
            }

        }

    </script>
    <script src="./script.js"></script>
</body>

</html>